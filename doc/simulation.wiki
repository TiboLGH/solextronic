<title>Simulation et Tests</title>

   *   [./index.wiki | Accueil] 
   *   [./gallery.wiki | Galerie] 
   *   [./schema.wiki | Schema]
   *   [./firmware.wiki | Firmware]
   *   [./software.wiki | Software]
   *   [./simulation.wiki | Simulation]
   *   [./todo.wiki | Roadmap et Todo List]
   *   [./links.wiki | Liens]

Le firmware est concu pour tourner sur un Atmel ATMega328 utilisé sur les cartes Arduino. Il est programme en C "pur" + AVR LibC, donc sans les librairies Arduino. 

La simulation s'effectue grace à SimAvr, projet libre de simulation de core AVR. La particularite de ce simulateur est pouvoir être utilise de plusieurs façon :

    *  simulateur classique avec un interface GDB intégrée pour faire du debug pas-à-pas, visualisation de variables...
	*  generateur de fichiers waveform VCD des registres internes (voir un exemple dans les liens en fin de page)
	*  librairie utilisable dans un programme de test : le coeur de simulation est piloté par ce programme et des périphériques peuvent être simulés.
	
C'est cette dernière approche qui sera utilisée pour permettre d'implementer des tests de régression automatiques. L'idée est d'avoir quelquechose de très automatique donc facile à lancer, ce qui incite à l'utiliser le plus souvent possible.

<h2>1. Architecture</h2>

  
<h2>2. Peripheriques simules</h2>
<h3>2.1. UART</h3>
Ce peripherique permet de creer un pont vers le port serie du microcontroleur.  Le port virtuel /dev/pts/5 est créé, on peut se connecter directement avec screen/minicom/picocom...

Ce composant reprends directement le composant uart_pty.h livré par simavr.

Il est connecté au microcontroleur simulé par le port UART.

<h3>2.2. Pulse_input</h3>
Ce composant émule un generateur de signal rectangulaire. Le but est d'émulé les impulsions PMH et compteur de vitesse.

Il est possible de régler le temps à l'état haut et le temps à l'état bas.

<h3>2.3. Analog_driver</h3>
Ce composant émule les entrées analogiques : température, papillon de gaz, niveau de batterie...

<h3>2.4. Flyback_supply</h3>
Ce composant émule l'alimentation haute tension Flyback. Il permet de valider le comportement de la coucle d'asservissement de l'alimentation HT.

L'entrée du composant est la valeur de PWM fournie par le microcontroleur, la sortie est un signal logique donnant l'état de la tension interne par rapport à un seuil prédéfini :

	0 : tension interne sous le seuil

	1 : tension interne au-dessus du seuil

Ce seuil est réglable (par défaut il est à 400v).
Le comportement dynamique se base sur la formule suivante :

	V(int_N) = 20% * (PWM / 256) x 500v + 80% * V(int_N-1) x 95%

La formule est réévaluée toutes les 10 ms. La valeur est la tesion interne est accessible pour tracer des graphes dans un fichier VCD.

<h3>2.4. Timing_Analyzer</h3>
Ce composant se place sur les sorties allumage et injection. Il est aussi connecté au signal sortant du pulse_input emulant le capteur PMH.

Il permet de calculer les timings des signaux d'allumage et d'injection :

	*  temps à l'état ON
	*  retard/avance par rapport au PMH

A partir de ces timings et des autres parametres (RPM, temperature...), le banc de test peut valider l'application de la loi de pilotage d'allumage et d'injection.

<h3>2.5. LCD_Button_i2c</h3>
Ce composant émule le "RGB LCD Shield Kit" de AdaFruit ([http://www.adafruit.com/products/714]). Il est interfacé en i2c et comporte un LCD 2x16 characters + 6 boutons.

Le LCD n'est pas rendu en OpenGL (possible avec SimAvr !), mais le buffer de texte affiché est disponible pour le banc de test.


<h2>3. Tests disponibles</h2>
<h3>3.1. Appel du sequenceur de test</h3>

./simMain.exe <option> elfFile

	-a			lance tous les tests disponibles

	-l			liste des tests disponibles

	-t "test"	lance le test "test"

	-m		mode manuel, le server GBD est activé, la communication UART disponible sur /dev/pts/5, le temps de simulation est infini

	-h 		message d'aide

	<elfFile>	chemin vers le fichier .elf 


<h3>3.2. Liste des tests </h3> 

<blockquote><center><table border=1 cellpadding=5>
<tr><th>Test</th><th>Description</th></tr>
<tr><td>Version</td><td> </td></tr>
<tr><td>RPM</td><td> </td></tr>
<tr><td>Vitesse</td><td> </td></tr>
<tr><td>Temperature</td><td></td></tr>
<tr><td>Batterie</td><td></td></tr>
<tr><td>Accelerateur</td><td></td></tr>
<tr><td>Alim HT</td><td></td></tr>
<tr><td>Allumage</td><td></td></tr>
<tr><td>Injection</td><td></td></tr>
<tr><td>Clavier/ecran</td><td></td></tr>
</table></center></blockquote>

<h3>3.3. Compilation</h3>
Le makefile principale contient une cible "sim". Un simple "make sim" compile à la fois le firmware et le programme de simulation.
Le seul ajustement à faire est de faire pointer le makefile sur le chemin de simavr (qui doit bien sur avoir été compilé !).


<h2>4. Liens</h2>
[http://ingo.orgizm.net/articles/2012-02-02-simulating-and-inspecting-code-with-gdb-and-simavr]

[https://github.com/buserror-uk/simavr]
